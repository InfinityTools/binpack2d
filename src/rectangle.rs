//! A structure that represents the placement of a single object in a bin.

use std::fmt::{Display, Formatter};
use super::dimension::{self, Dimension};

/// `Rectangle` specifies an area in a coordinate space that is defined an upper-left point,
/// as defined by `x` and `y`, and the dimensions, defined by the [`Dimension`] object.
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd)]
pub struct Rectangle {
    x: u32,
    y: u32,
    dim: Dimension,
}

impl Rectangle {
    /// Creates a new `Rect` whose upper-left corner is defined by `x` and `y`, and whose `width`
    /// and `height` are defined by the [`Dimension`] type.
    pub fn new(x: u32, y: u32, dim: Dimension) -> Rectangle {
        Rectangle { x, y, dim }
    }

    /// Returns the x coordinate of the bounding `Rectangle`.
    pub fn x(&self) -> u32 {
        self.x
    }

    /// Returns the y coordinate of the bounding `Rectangle`.
    pub fn y(&self) -> u32 {
        self.y
    }

    /// Moves this `Rectangle` horizontally to the location specified by x.
    pub fn set_x(&mut self, x: u32) {
        self.x = x;
    }

    /// Moves this `Rectangle` vertically to the location specified by y.
    pub fn set_y(&mut self, y: u32) {
        self.y = y;
    }

    /// Moves this `Rectangle` to the location specified by x and y.
    pub fn set_location(&mut self, x: u32, y: u32) {
        self.x = x;
        self.y = y;
    }

    /// Translates this `Rectangle` the indicated distance, to the right along the X axis,
    /// and downward along the Y axis.
    ///
    /// **Note:** Underflow and overflow are bound by 0 and [`u32::MAX`] respectively.
    pub fn translate(&mut self, dx: i32, dy: i32) {
        if dx != 0 {
            self.x = (self.x as i64 + dx as i64).clamp(0, u32::MAX as i64) as u32;
        }
        if dy != 0 {
            self.y = (self.y as i64 + dy as i64).clamp(0, u32::MAX as i64) as u32;
        }
    }

    /// Returns the identifier associated with the `Rectangle`.
    pub fn id(&self) -> isize {
        self.dim.id()
    }

    /// Returns the width of the bounding `Rectangle`.
    pub fn width(&self) -> u32 {
        self.dim.width()
    }

    /// Returns the height of the bounding `Rectangle`.
    pub fn height(&self) -> u32 {
        self.dim.height()
    }

    /// Returns an immutable reference to the associated [`Dimension`] object.
    pub fn dim(&self) -> &Dimension {
        &self.dim
    }

    /// Returns a mutable reference to the associated [`Dimension`] object.
    pub fn dim_mut(&mut self) -> &mut Dimension {
        &mut self.dim
    }

    /// Returns `true` if `width` or `height` of the `Rectangle` is 0, and `false` otherwise.
    pub fn is_empty(&self) -> bool {
        self.dim.is_empty()
    }

    /// Checks whether or not this `Rectangle` entirely contains the specified `Rectangle`.
    pub fn contains(&self, rect: &Rectangle) -> bool {
        rect.x >= self.x
            && rect.y >= self.y
            && rect.x + rect.width() <= self.x + self.width()
            && rect.y + rect.height() <= self.y + self.height()
    }

    /// Checks whether or not this `Rectangle` and the specified `Rectangle` intersect.
    pub fn intersects(&self, rect: &Rectangle) -> bool {
        let mut tw = self.width();
        let mut th = self.height();
        let mut rw = rect.width();
        let mut rh = rect.height();
        if rw == 0 || rh == 0 || tw == 0 || th == 0 {
            return false;
        }

        let tx = self.x;
        let ty = self.y;
        let rx = rect.x;
        let ry = rect.y;
        rw += rx;
        rh += ry;
        tw += tx;
        th += ty;
        // overflow || intersect
        (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry)
    }

    /// Computes the union of this `Rectangle` with the specified `Rectangle`.
    ///
    /// `rect` specifies the second rectangle to use for the union.
    /// `id` will be used as new identifier for the dimension included the returned `Rectangle`.
    /// An identifier is autogenerated if if `None` is specified.
    ///
    /// Returns a new `Rectangle` that represents the union of the two rectangles.
    pub fn union(&self, rect: &Rectangle, id: Option<isize>) -> Self {
        let min_x = self.x.min(rect.x);
        let min_y = self.y.min(rect.y);

        let max_x = (self.x as u64 + self.width() as u64).max(rect.x as u64 + rect.width() as u64);
        let width = (max_x - min_x as u64).min(u32::MAX as u64) as u32;

        let max_y =
            (self.y as u64 + self.height() as u64).max(rect.y as u64 + rect.height() as u64);
        let height = (max_y - min_y as u64).min(u32::MAX as u64) as u32;

        let id = id.unwrap_or_else(dimension::get_unique_id);

        Self {
            x: min_x,
            y: min_y,
            dim: Dimension::with_id(id, width, height),
        }
    }
}

impl From<Dimension> for Rectangle {
    fn from(value: Dimension) -> Self {
        Rectangle::new(0, 0, value)
    }
}

impl Display for Rectangle {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Rectangle(x: {}, y: {}, dim: {})", self.x, self.y, self.dim)
    }
}


#[cfg(test)]
mod tests;
